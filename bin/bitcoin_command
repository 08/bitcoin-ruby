#!/usr/bin/env ruby
$:.unshift( File.expand_path("../../lib", __FILE__) )

require 'eventmachine'
require 'json'
require 'bitcoin'
require 'optparse'

defaults = {
  :command => "127.0.0.1:9999"
}
options = Bitcoin::Config.load(defaults, :command)

optparse = OptionParser.new do |opts|
  opts.banner =
    "Usage: bitcoin_command [options] <command> [<command options>]\n"

  opts.separator("\nAvailable options:\n")

  opts.on("-c", "--config FILE",
    "Config file (default: #{Bitcoin::Config::CONFIG_PATHS})") do |file|
    options = Bitcoin::Config.load_file(options, file, :wallet)
  end

  opts.on("--command HOST:PORT",
    "Node command socket (default: #{options[:command]})") do |command|
    options[:command] = command
  end

  opts.on("-h", "--help", "Display this help") do
    puts opts; exit
  end

  opts.separator "\nAvailable commands:\n" +
    "run `bitcoin_command help` to see all available commands."
end

optparse.parse!
host, port = options[:command].split(":")
unless ARGV.any?
  puts optparse; exit
end

EM.run do
  Bitcoin::Network::CommandClient.connect(host, port) do

    on_response do |cmd, data|
      EM.stop  unless cmd == "monitor"
    end
    on_info do |info|
      puts JSON.pretty_generate(info)
    end
    on_connections do |connections|
      puts *connections
    end
    [:connect, :disconnect, :getblocks, :getaddr, :relay_tx, :stop].each do |req|
      send("on_#{req}") {|res| p res}
    end

    on_block do |block, depth|
      puts "block: #{block['hash']} (#{depth})"
    end
    on_tx do |tx|
      puts "tx: #{tx['hash']}"
    end
    on_connection do |type, host|
      if type == "connected"
        puts "Connected: #{host['host']}:#{host['port']}"
      else
        puts "Disconnected: #{host.inspect}"
      end
    end

    on_connected do
      request(ARGV[0], *(ARGV[1] || "").split(" "))
    end

  end
end
