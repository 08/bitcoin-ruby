#!/usr/bin/env ruby
$:.unshift( File.expand_path("../../lib", __FILE__) )

require 'eventmachine'
require 'json'
require 'bitcoin'
require 'optparse'

defaults = {
  :command => "127.0.0.1:9999"
}
options = Bitcoin::Config.load(defaults, :command)

optparse = OptionParser.new do |opts|
  opts.banner =
    "Usage: bitcoin_command [options] <command> [<command options>]\n"

  opts.separator("\nAvailable options:\n")

  opts.on("-c", "--config FILE",
    "Config file (default: #{Bitcoin::Config::CONFIG_PATHS})") do |file|
    options = Bitcoin::Config.load_file(options, file, :wallet)
  end

  opts.on("--command HOST:PORT",
    "Node command socket (default: #{options[:command]})") do |command|
    options[:command] = command
  end

  opts.on("-h", "--help", "Display this help") do
    puts opts; exit
  end

  opts.separator "\nAvailable commands:\n" +
    "run `bitcoin_command help` to see all available commands."
end

optparse.parse!
host, port = options[:command].split(":")
unless ARGV.any?
  puts optparse; exit
end

EM.run do

  EM.connect(host, port) do |connection|

    connection.send_data([ARGV[0], ARGV[1..-1].join(" ")].to_json + "\x00")

    def connection.receive_data(data)
      (@buf ||= BufferedTokenizer.new("\x00")).extract(data).each do |packet|
        cmd, result = JSON.load(packet)
        next  unless cmd == ARGV[0]
        if cmd == "monitor"
          type, obj, depth = result
          puts "#{type}: #{obj['hash'] rescue 'none'} #{depth ? "(#{depth})" : ""}"
        else
          puts JSON.pretty_generate(result)
          EM.stop
        end
      end
    end

    def connection.unbind
      puts "Disconnected."
      EM.stop
    end

  end
end
